# 学习任务
- [x] [线程](#jump1) 
- [ ] [反射](#jump2) 
- [x] [委托](#jump3) 
- [x] [接口](#jump4) 
- [ ] 异步 TPL Task类
- [ ] [SQL基础](#jump6) 
- [ ] [asp.net mvc框架](#jump7) 
- [ ] 响应http请求 post参数 连数据库
- [ ] Entity Framework
**************************
- [ ] 泛型
- [ ] 异常
- [ ] List类
- [ ] PCL
- [ ] Queue类
- [ ] AttributeUsage类
- [ ] 数据加密

# 问题
1. 两个选择器之前的or和and关系怎么理解？

## <span id="jump1">线程</span>  
1. Thread方法：
   - Thread 实例名 = new Thread(线程方法)
   - void 线程方法 () 或 void 线程方法 (Object obj)
2. IsBackground属性：
   - 设置或判断前台或后台线程
   - 所有前台线程终止后，进程结束
3.  <!---->
   ![线程状态](./笔记and笔记图片/线程状态.jpeg)
4. Join方法：
   - 阻塞当前线程，直到指定的线程终止
   - 即排到一个指定线程之后进行
5. Invoke方法：
   - 多个并发线程同时访问同一控件
   - 首先查询InvokeRequired属性，为true，则需要使用Invoke方法访问
   - 用委托调用方法
6. lock关键字：
   - 当一个线程位于代码的临界区时，另一个线程不进入临界区。如果试图进入，则会一直处于阻塞状态（等待）
   - ``` C #
     Object thislock = new Object();
     lock(thislock)
     {
         //临界区
     }
     ```

## <span id="jump4">接口</span>  
1. 派生类包含方法的规定
2. 接口不能包含方法的具体实现，接口中声明的方法要由继承接口的类给出具体实现

## <span id="jump3">委托</span>  
1. 相当于指向方法的指针
2. 委托可以调用与委托返回值类型、参数个数、参数类型完全相同的方法
3. 可以将多个方法赋给同一个委托
   ``` C #
   委托类型名 delegatalExample = new 委托类型名(方法名1);
   delegatalExample += 方法名2；
   ```

## <span id="jump6">数据库</span>  
1. 常见数据对象：
   - 表（Table）：
     - 列称为“字段”，行称为“记录”
     - 每个表通常有一个主关键字，用于唯一地确定一条记录
   - 索引（Index）
     - 快速访问数据
     - 监督其所指向列中的数据不重复
   - 视图（View）
     - 一个虚拟的表，具有一组命名的列和数据项
     - 视图由查询数据表产生，只显示需要的数据信息
     - 控制用户访问
   - 图表（Diagram）
     - 数据库表之间的关系示意图
     - 可以编辑表与表之间的关系
   - 默认值（Default）
   - 规则（Rule）
     - 限制表中的列
   - 触发器（Trigger）
     - 当对一个表进行插入、更改或删除时，自动执行一组命令
2.  <!---->
   ![SQL语言核心关键字](./笔记and笔记图片/SQL语言核心关键字.jpg)

## <span id="jump7">ASP.net</span> 
1. HTML元素
   ![常见的HTML元素](./笔记and笔记图片/常见的HTML元素1.jpg)
   ![常见的HTML元素](./笔记and笔记图片/常见的HTML元素2.jpg)
   - meta	:表示那些不能由其它 HTML 元相关（meta-related）元素（(base、link, script、style 或 title）之一表示的任何Metadata信息。
   - style:包含文档的样式信息或者文档的部分内容。默认情况下，该标签的样式信息通常是CSS的格式。
2. CSS
   - 专门用于控制样式，包含背景、颜色、字体等
   - ```C
      h1,h2 .special // 选择器规则，可以有多个选择器
      {  //规则
         color : red;
         font - size：26px;
      }
     ```
      - 可以有多个选择器
      - ,"表明选择器之间为or关系；“ ”表明选择器之间为and关系，and表明这些选择器是继承的
      - h1为*类型选择器*，页面上所有的HTML元素“h1”
      - .special为*类选择器*，这个类标记的所有元素上
      - id选择器：用#创建
         ```C
            #mainaArticle{
               color:red;
            }
         ```
       - 通用选择器：用*创建,适用与页面上的每个元素
         ```C
            * {
               color:red;
            }
         ``` 
   ![CSS属性](./笔记and笔记图片/CSS属性1.jpg)
   ![CSS属性](./笔记and笔记图片/CSS属性2.jpg)
3. MVC
   1. 模型：执行业务逻辑
     视图：用户页面创建
     控制器：接受视图的信息，并给视图提供信息
   2. Razor语法
      - Html.Display方法
   3. 路由

## 数据加密
1. 密钥对，在非对称加密技术中，有两种密钥，分为私钥和公钥，私钥是密钥对所有者持有，不可公布，公钥是密钥对持有者公布给他人的。

1. 公钥，公钥用来给数据加密，用公钥加密的数据只能使用私钥解密。

1. 私钥，如上，用来解密公钥加密的数据。

1. 摘要，对需要传输的文本，做一个HASH计算，一般采用SHA1，SHA2来获得。

1. 数字签名，使用私钥对需要传输的文本的摘要进行加密，得到的密文即被称为该次传输过程的签名。

1. 签名验证，数据接收端，拿到传输文本，但是需要确认该文本是否就是发送发出的内容，中途是否曾经被篡改。因此拿自己持有的公钥对签名进行解密，得到了文本的摘要，然后使用与发送方同样的HASH算法计算摘要值，再与解密得到的摘要做对比，发现二者完全一致，则说明文本没有被篡改过。
1. 使用说明：如果用其中一个密钥加密一段数据，必须用另一个密钥解密。比如用公钥加密数据就必须用私钥解密，如果用私钥加密也必须用公钥解密，否则解密将不会成功。
2. 填充模式（padding）：
   - false 不填充前面自动填0补齐，解密后签名也是0

      

###杂项
1. XML注释
2. lambda表达式
   - x => RunSomeMethod(x)
   - y => y.SomeMethod